import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/theme/theme_colors.dart';
import '../../../../core/services/sound_manager.dart';
import '../../../../core/services/database_helper.dart';
import '../../../../core/utils/app_logger.dart';
import '../../../../utils/color_utils.dart';
import '../../../../services/tag_service.dart';
import '../../../../features/ai_motivation/presentation/cubit/motivation_cubit.dart';
import '../../../../features/ai_split/presentation/cubit/ai_split_cubit.dart';
import '../../../../features/ai_split/data/models/subtask_model.dart';
import '../../../../features/pomodoro/domain/entities/pomodoro_session.dart';
import '../../../../features/ai_chat/presentation/pages/ai_chat_page.dart';
import '../../../../features/ai_prank/presentation/cubit/prank_cubit.dart';
import '../../../../features/profile/presentation/bloc/profile_bloc.dart';
import '../../../../features/profile/presentation/bloc/profile_state.dart';
import '../../../../features/profile/presentation/bloc/profile_event.dart';
import '../../../../features/profile/domain/entities/age_category.dart';
import '../../../../core/connectivity/cubit/connectivity_cubit.dart';
import '../../../../services/tag_parser.dart';
import '../../domain/entities/todo.dart';
import '../../domain/services/recurrence_generator.dart';
import '../bloc/todo_list_bloc.dart';
import '../bloc/todo_list_event.dart';
import '../bloc/todo_list_state.dart';
import 'todo_tag_chip.dart';
import 'recurrence_confirmation_dialog.dart';
import 'dialogs/motivation_dialog.dart';
import 'dialogs/pomodoro_quickstart_dialog.dart';
import 'dialogs/edit_todo_dialog.dart';
import 'dialogs/share_todo_handler.dart';

/// TodoCard - Karta s TODO √∫kolem
///
/// Features:
/// - Swipe doprava = toggle hotovo/nehotovo
/// - Swipe doleva = smazat
/// - Tap = expand/collapse
/// - Long press = edit
/// - Motivate button = AI motivace
class TodoCard extends StatelessWidget {
  final Todo todo;
  final bool isExpanded;

  const TodoCard({
    super.key,
    required this.todo,
    required this.isExpanded,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Dismissible(
      key: Key('todo_${todo.id}'),
      // Swipe doprava = toggle hotovo/nehotovo
      background: Container(
        margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: todo.isCompleted
              ? theme.appColors.yellow
              : theme.appColors.green,
          borderRadius: BorderRadius.circular(8),
        ),
        alignment: Alignment.centerLeft,
        padding: const EdgeInsets.only(left: 20),
        child: Row(
          children: [
            Icon(
              todo.isCompleted ? Icons.refresh : Icons.check_circle,
              color: theme.appColors.bg,
              size: 32,
            ),
            const SizedBox(width: 12),
            Text(
              todo.isCompleted ? 'VR√ÅTIT' : 'HOTOVO',
              style: TextStyle(
                color: theme.appColors.bg,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
      ),
      // Swipe doleva = AI Motivace
      secondaryBackground: Container(
        margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: theme.appColors.magenta,
          borderRadius: BorderRadius.circular(8),
        ),
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 20),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            Text(
              'MOTIVACE ‚ú®',
              style: TextStyle(
                color: theme.appColors.bg,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(width: 12),
            Icon(
              Icons.auto_awesome,
              color: theme.appColors.bg,
              size: 32,
            ),
          ],
        ),
      ),
      confirmDismiss: (direction) async {
        // Zav≈ô√≠t kl√°vesnici p≈ôi jak√©koli swipe akci
        FocusScope.of(context).unfocus();

        AppLogger.debug('üîÑ TODO CARD SWIPE: direction=$direction, todo=[${todo.id}] ${todo.task}');

        if (direction == DismissDirection.startToEnd) {
          // Swipe doprava = toggle hotovo/nehotovo
          AppLogger.debug('‚û°Ô∏è SWIPE DOPRAVA: isCompleted=${todo.isCompleted}, hasRecurrence=${todo.hasRecurrence}');

          // ‚úÖ Check: je to recurring √∫kol? (pouze pokud se dokonƒçuje)
          if (!todo.isCompleted && todo.hasRecurrence) {
            // RECURRING TODO ‚Üí show dialog
            final nextDate = RecurrenceGenerator.calculateNextDate(
              rule: todo.recurrenceRule!,
              currentDate: todo.dueDate ?? DateTime.now(),
            );

            if (nextDate == null) {
              // Chyba p≈ôi v√Ωpoƒçtu ‚Üí fallback normal complete
              context.read<TodoListBloc>().add(
                    ToggleTodoEvent(
                      id: todo.id!,
                      isCompleted: true,
                    ),
                  );

              // üìä Inkrementovat completed tasks count (pro st≈ô√≠d√°n√≠ prank/good deed)
              context.read<ProfileBloc>().add(const IncrementCompletedTasksEvent());

              // üéâ Trigger AI Prank/Good Deed pokud je u≈æivatel d√≠tƒõ
              _triggerPrankIfChild(context);

              return false;
            }

            // Zobrazit dialog
            AppLogger.debug('üìã Zobrazuji RecurrenceConfirmationDialog...');
            final shouldContinue = await showDialog<bool>(
              context: context,
              builder: (context) => RecurrenceConfirmationDialog(
                nextDate: nextDate,
              ),
            );

            AppLogger.debug('üìã Dialog zav≈ôen: shouldContinue=$shouldContinue');

            if (shouldContinue == true) {
              AppLogger.debug('‚úÖ User zvolil: POKRAƒåOVAT');

              // üéâ Trigger AI Prank/Good Deed P≈òED inkrementac√≠ (pot≈ôebujeme aktu√°ln√≠ count)
              AppLogger.debug('üéâ VOL√ÅM _triggerPrankIfChild() po POKRAƒåOVAT (P≈òED inkrementac√≠)...');
              _triggerPrankIfChild(context);

              // Pokraƒçovat ‚Üí posunout term√≠n
              context.read<TodoListBloc>().add(
                    ContinueRecurrenceEvent(todo.id!, nextDate),
                  );

              // üìä Inkrementovat completed tasks count (pro st≈ô√≠d√°n√≠ prank/good deed)
              context.read<ProfileBloc>().add(const IncrementCompletedTasksEvent());
            } else if (shouldContinue == false) {
              AppLogger.debug('üõë User zvolil: UKONƒåIT');

              // üéâ Trigger AI Prank/Good Deed P≈òED inkrementac√≠ (pot≈ôebujeme aktu√°ln√≠ count)
              AppLogger.debug('üéâ VOL√ÅM _triggerPrankIfChild() po UKONƒåIT (P≈òED inkrementac√≠)...');
              _triggerPrankIfChild(context);

              // Ukonƒçit ‚Üí smazat rule + complete
              context.read<TodoListBloc>().add(
                    EndRecurrenceEvent(todo.id!),
                  );

              // üìä Inkrementovat completed tasks count (pro st≈ô√≠d√°n√≠ prank/good deed)
              context.read<ProfileBloc>().add(const IncrementCompletedTasksEvent());
            } else {
              AppLogger.debug('‚ùå User zav≈ôel dialog (shouldContinue=null)');
            }
            // null = dialog dismissed ‚Üí nic nedƒõlat

            return false; // Neodstranit widget
          } else {
            // Bƒõ≈æn√Ω TODO nebo vr√°tit hotov√Ω ‚Üí norm√°ln√≠ toggle
            final isCompletingNow = !todo.isCompleted; // true pokud pr√°vƒõ dokonƒçujeme

            AppLogger.debug('üìù Bƒö≈ΩN√ù TODO: isCompletingNow=$isCompletingNow');

            context.read<TodoListBloc>().add(
                  ToggleTodoEvent(
                    id: todo.id!,
                    isCompleted: isCompletingNow,
                  ),
                );

            // üìä Inkrementovat completed tasks count (pouze pokud dokonƒçujeme)
            if (isCompletingNow) {
              AppLogger.debug('üìä Inkrementuji completed tasks count...');
              context.read<ProfileBloc>().add(const IncrementCompletedTasksEvent());
            }

            // üéâ Trigger AI Prank/Good Deed pokud je u≈æivatel d√≠tƒõ
            if (isCompletingNow) {
              AppLogger.debug('üéâ VOL√ÅM _triggerPrankIfChild()...');
              _triggerPrankIfChild(context);
            }

            return false; // Neodstranit widget
          }
        } else {
          // Swipe doleva = AI Motivace
          await _motivateTask(context);
          return false; // Neodstranit widget
        }
      },
      child: InkWell(
        onTap: () {
          // Zav≈ô√≠t kl√°vesnici p≈ôi expand/collapse
          FocusScope.of(context).unfocus();

          context
              .read<TodoListBloc>()
              .add(ToggleExpandTodoEvent(isExpanded ? null : todo.id));
        },
        onLongPress: () {
          // Zav≈ô√≠t kl√°vesnici p≈ôi otev≈ôen√≠ edit dialogu
          FocusScope.of(context).unfocus();
          EditTodoDialog.show(
            context,
            todo: todo,
            onShare: () => ShareTodoHandler.share(context, todo: todo),
          );
        },
        child: Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: theme.appColors.bgAlt,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: _getTodoBorderColor(context),
              width: 1, // Subtiln√≠ border (clean minimal)
            ),
          ),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Obsah (ID + text + metadata)
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Prvn√≠ ≈ô√°dek: ID + text √∫kolu
                    Row(
                      children: [
                        // ID
                        Text(
                          '[${todo.id}]',
                          style: TextStyle(
                            color: theme.appColors.base5,
                            fontSize: 14,
                            fontWeight: FontWeight.bold,
                            fontFamily: 'monospace',
                          ),
                        ),
                        const SizedBox(width: 8),
                        // Text √∫kolu (o≈ô√≠znut√Ω nebo pln√Ω)
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                todo.task,
                                maxLines: isExpanded ? null : 1,
                                overflow:
                                    isExpanded ? null : TextOverflow.ellipsis,
                                style: TextStyle(
                                  decoration: todo.isCompleted
                                      ? TextDecoration.lineThrough
                                      : TextDecoration.none,
                                  color: todo.isCompleted
                                      ? theme.appColors.base5
                                      : theme.appColors.fg,
                                  fontSize: 16,
                                ),
                              ),

                              // Roz≈°√≠≈ôen√© info: Subtasks + AI metadata (pouze pokud expanded)
                              if (isExpanded) ...[
                                const SizedBox(height: 12),
                                _buildExpandedDetails(context, theme),
                              ],
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),

                    // Druh√Ω ≈ô√°dek: Metadata (priorita, datum, akce, tagy, subtasks)
                    Wrap(
                      spacing: 6,
                      runSpacing: 4,
                      children: [
                        // Priorita (s u≈æivatelskou barvou z TagService)
                        if (todo.priority != null) ...[
                          () {
                            final priorityDef = TagService().getDefinition(todo.priority!);
                            return TodoTagChip(
                              text:
                                  '${TagParser.getPriorityIcon(todo.priority)} ${todo.priority!.toUpperCase()}',
                              color: priorityDef?.color != null
                                  ? ColorUtils.hexToColor(priorityDef!.color!)
                                  : _getPriorityColorFallback(context),
                              glowEnabled: priorityDef?.glowEnabled ?? false,
                              glowStrength: priorityDef?.glowStrength ?? 0.5,
                            );
                          }(),
                        ],

                        // Datum (s u≈æivatelskou barvou z TagService)
                        if (todo.dueDate != null) ...[
                          () {
                            final dateText = TagParser.formatDate(todo.dueDate!);
                            // Extrahovat jen date ƒç√°st (bez ƒçasu) pro TagService lookup
                            // Nap≈ô: "dnes 13:00" ‚Üí "dnes", "z√≠tra 9:30" ‚Üí "z√≠tra"
                            final datePart = dateText.split(' ').first;
                            final dateDef = TagService().getDefinition(datePart);
                            return TodoTagChip(
                              text: 'üìÖ $dateText',
                              color: dateDef?.color != null
                                  ? ColorUtils.hexToColor(dateDef!.color!)
                                  : theme.appColors.blue,
                              glowEnabled: dateDef?.glowEnabled ?? false,
                              glowStrength: dateDef?.glowStrength ?? 0.5,
                            );
                          }(),
                        ],

                        // üîÅ Ikona + frekvence (pokud m√° recurrence)
                        if (todo.hasRecurrence) ...[
                          TodoTagChip(
                            text: 'üîÅ ${RecurrenceGenerator.formatRecurrenceFrequency(todo.recurrenceRule!)}',
                            color: theme.appColors.magenta,
                          ),
                        ],

                        // Subtasks poƒç√≠tadlo
                        if (todo.subtasks != null && todo.subtasks!.isNotEmpty)
                          TodoTagChip(
                            text: 'ü§ñ ${todo.subtasks!.where((s) => s.completed).length}/${todo.subtasks!.length}',
                            color: theme.appColors.cyan,
                          ),

                        // Obecn√© tagy (s u≈æivatelsk√Ωmi barvami z TagService)
                        ...todo.tags.map((tag) {
                          final tagDef = TagService().getDefinition(tag);
                          return TodoTagChip(
                            text: tag,
                            color: tagDef?.color != null
                                ? ColorUtils.hexToColor(tagDef!.color!)
                                : theme.appColors.cyan,
                            glowEnabled: tagDef?.glowEnabled ?? false,
                            glowStrength: tagDef?.glowStrength ?? 0.5,
                          );
                        }),
                      ],
                    ),
                  ],
                ),
              ),

              // Tlaƒç√≠tko pro roz≈°i≈ôuj√≠c√≠ funkce (AI Chat, Pomodoro, Motivace)
              _buildActionsMenuButton(context),
            ],
          ),
        ),
      ),
    );
  }

  /// Z√≠skat barvu r√°meƒçku √∫kolu podle stavu (Doom One styl: clean + elegant)
  Color _getTodoBorderColor(BuildContext context) {
    final theme = Theme.of(context);
    if (todo.isCompleted) {
      // Splnƒõn√© √∫koly = kr√°sn√° modern√≠ zelen√° (celebrate the win!)
      return theme.appColors.green;
    } else {
      // Aktivn√≠ √∫koly = pƒõkn√° decentn√≠ cyan/modr√° (Doom One styl)
      return theme.appColors.cyan.withValues(alpha: 0.4);
    }
  }

  /// Vytvo≈ôit rozbalovac√≠ menu s akcemi (AI Chat, Pomodoro, Motivace)
  Widget _buildActionsMenuButton(BuildContext context) {
    final theme = Theme.of(context);

    return PopupMenuButton<String>(
      icon: Icon(
        Icons.auto_awesome,
        color: theme.appColors.magenta,
        size: 20,
      ),
      tooltip: '', // Vypnuto kv≈Øli multiple tickers error p≈ôi rebuildu
      color: theme.appColors.bg,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
        side: BorderSide(color: theme.appColors.magenta, width: 1),
      ),
      itemBuilder: (context) => [
        // AI Chat
        PopupMenuItem<String>(
          value: 'ai_chat',
          child: Row(
            children: [
              const Text('ü§ñ', style: TextStyle(fontSize: 18)),
              const SizedBox(width: 12),
              Text(
                'Chat s AI',
                style: TextStyle(color: theme.appColors.fg),
              ),
            ],
          ),
        ),
        // Pomodoro
        PopupMenuItem<String>(
          value: 'pomodoro',
          child: Row(
            children: [
              const Text('üçÖ', style: TextStyle(fontSize: 18)),
              const SizedBox(width: 12),
              Text(
                'Spustit Pomodoro',
                style: TextStyle(color: theme.appColors.fg),
              ),
            ],
          ),
        ),
        // Motivace
        PopupMenuItem<String>(
          value: 'motivation',
          child: Row(
            children: [
              const Text('‚ú®', style: TextStyle(fontSize: 18)),
              const SizedBox(width: 12),
              Text(
                'AI Motivace',
                style: TextStyle(color: theme.appColors.fg),
              ),
            ],
          ),
        ),
      ],
      onSelected: (value) {
        switch (value) {
          case 'ai_chat':
            _openAiChat(context);
            break;
          case 'pomodoro':
            PomodoroQuickStartDialog.show(context, todo: todo);
            break;
          case 'motivation':
            _motivateTask(context);
            break;
        }
      },
    );
  }

  /// Z√≠skat fallback barvu pro prioritu (pokud nen√≠ definice v TagService)
  Color _getPriorityColorFallback(BuildContext context) {
    final theme = Theme.of(context);
    switch (todo.priority) {
      case 'a':
        return theme.appColors.red;
      case 'b':
        return theme.appColors.yellow;
      case 'c':
        return theme.appColors.green;
      default:
        return theme.appColors.base5;
    }
  }



  /// Z√≠skat AI motivaci pro √∫kol (s cache kontrolou)
  Future<void> _motivateTask(BuildContext context) async {
    AppLogger.debug('üöÄ _motivateTask START pro √∫kol: ${todo.task}');

    // Zav≈ô√≠t kl√°vesnici (pokud je otev≈ôen√°)
    FocusScope.of(context).unfocus();

    // Zkontrolovat zda existuje cached motivace
    if (todo.aiMotivation != null && todo.aiMotivation!.isNotEmpty) {
      // Motivace existuje ‚Üí OKAM≈ΩITƒö zobrazit (BEZ loading)
      AppLogger.debug('üíæ Zobrazuji CACHED motivaci');
      MotivationDialog.show(
        context,
        todo: todo,
        motivation: todo.aiMotivation!,
        isCached: true,
        onRegenerate: () => _generateAndShowMotivation(context),
      );
    } else {
      // ≈Ω√°dn√° motivace ‚Üí vygenerovat NOVOU
      AppLogger.debug('üÜï Generuji NOVOU motivaci');
      await _generateAndShowMotivation(context);
    }
  }

  /// Vygenerovat NOVOU motivaci + ulo≈æit do DB
  Future<void> _generateAndShowMotivation(BuildContext context) async {
    final theme = Theme.of(context);
    final soundManager = SoundManager();

    AppLogger.debug('üîä Spou≈°t√≠m typing_long zvuk');
    await soundManager.playTypingLong();

    // Zobrazit loading dialog
    AppLogger.debug('‚è≥ Zobrazuji loading dialog');
    if (!context.mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => Center(
        child: CircularProgressIndicator(
          color: theme.appColors.magenta,
        ),
      ),
    );

    try {
      AppLogger.debug('ü§ñ Vol√°m MotivationCubit.fetchMotivation...');
      // Zavolat API
      final motivation = await context.read<MotivationCubit>().fetchMotivation(
        taskText: todo.task,
        priority: todo.priority,
        tags: todo.tags,
      );
      AppLogger.debug(
          '‚úÖ AI odpovƒõƒè obdr≈æena: ${motivation.substring(0, motivation.length > 50 ? 50 : motivation.length)}...');

      // Ulo≈æit do datab√°ze
      final now = DateTime.now().millisecondsSinceEpoch ~/ 1000; // Unix timestamp (seconds)
      final updatedTodo = todo.copyWith(
        aiMotivation: motivation,
        aiMotivationGeneratedAt: now,
      );

      if (context.mounted) {
        context.read<TodoListBloc>().add(UpdateTodoEvent(updatedTodo));
      }

      // Zastavit zvuk
      AppLogger.debug('‚èπÔ∏è Zastavuji typing_long zvuk');
      await soundManager.stop();

      // Zav≈ô√≠t loading dialog
      AppLogger.debug('‚ùå Zav√≠r√°m loading dialog');
      if (context.mounted) Navigator.of(context).pop();

      // Zobrazit motivaci s updatedTodo (obsahuje novou motivaci)
      AppLogger.debug('üìù Zobrazuji motivaƒçn√≠ dialog');
      if (context.mounted) {
        MotivationDialog.show(
          context,
          todo: updatedTodo, // ‚úÖ Pou≈æ√≠t updatedTodo s novou motivac√≠
          motivation: motivation,
          isCached: false,
          onRegenerate: () => _generateAndShowMotivation(context),
        );
      }
      AppLogger.debug('‚úÖ _generateAndShowMotivation KONEC (√∫spƒõch)');
    } catch (e, stackTrace) {
      AppLogger.error('‚ùå EXCEPTION v _generateAndShowMotivation', error: e, stackTrace: stackTrace);

      // Zastavit zvuk p≈ôi chybƒõ
      await soundManager.stop();

      // Zav≈ô√≠t loading dialog
      if (context.mounted) Navigator.of(context).pop();

      // Zobrazit error
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Chyba p≈ôi z√≠sk√°v√°n√≠ motivace: $e'),
            backgroundColor: theme.appColors.red,
          ),
        );
      }
      AppLogger.debug('‚úÖ _generateAndShowMotivation KONEC (chyba)');
    }
  }

  /// Roz≈°√≠≈ôen√© detaily: Subtasks + AI metadata
  Widget _buildExpandedDetails(BuildContext context, ThemeData theme) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Subtasks
        if (todo.subtasks != null && todo.subtasks!.isNotEmpty) ...[
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.appColors.base1,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: theme.appColors.cyan, width: 1),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'üìã POD√öKOLY:',
                  style: TextStyle(
                    color: theme.appColors.cyan,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                ...todo.subtasks!.map((subtask) {
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 4),
                    child: Dismissible(
                      key: Key('subtask_${subtask.id}'),
                      // Swipe doprava = toggle hotovo/nehotovo
                      background: Container(
                        decoration: BoxDecoration(
                          color: subtask.completed
                              ? theme.appColors.yellow
                              : theme.appColors.green,
                          borderRadius: BorderRadius.circular(4),
                        ),
                        alignment: Alignment.centerLeft,
                        padding: const EdgeInsets.only(left: 12),
                        child: Icon(
                          subtask.completed ? Icons.refresh : Icons.check,
                          color: theme.appColors.bg,
                          size: 20,
                        ),
                      ),
                      // Swipe doleva = smazat
                      secondaryBackground: Container(
                        decoration: BoxDecoration(
                          color: theme.appColors.red,
                          borderRadius: BorderRadius.circular(4),
                        ),
                        alignment: Alignment.centerRight,
                        padding: const EdgeInsets.only(right: 12),
                        child: Icon(
                          Icons.delete,
                          color: theme.appColors.bg,
                          size: 20,
                        ),
                      ),
                      confirmDismiss: (direction) async {
                        if (direction == DismissDirection.startToEnd) {
                          // Swipe doprava = toggle
                          await context
                              .read<AiSplitCubit>()
                              .toggleSubtask(subtask.id!, !subtask.completed);
                          // Reload todo list
                          if (context.mounted) {
                            context
                                .read<TodoListBloc>()
                                .add(const LoadTodosEvent());
                          }
                          return false; // Neodstranit widget
                        } else {
                          // Swipe doleva = smazat
                          return true; // Odstranit widget
                        }
                      },
                      onDismissed: (direction) async {
                        if (direction == DismissDirection.endToStart) {
                          // Smazat subtask
                          await context
                              .read<AiSplitCubit>()
                              .deleteSubtask(subtask.id!);
                          // Reload todo list
                          if (context.mounted) {
                            context
                                .read<TodoListBloc>()
                                .add(const LoadTodosEvent());
                          }
                        }
                      },
                      child: Row(
                        children: [
                          Checkbox(
                            value: subtask.completed,
                            onChanged: (value) async {
                              // Toggle subtask completed
                              await context
                                  .read<AiSplitCubit>()
                                  .toggleSubtask(subtask.id!, value!);
                              // Reload todo list pro zobrazen√≠ zmƒõn
                              if (context.mounted) {
                                context
                                    .read<TodoListBloc>()
                                    .add(const LoadTodosEvent());
                              }
                            },
                            activeColor: theme.appColors.green,
                          ),
                          Expanded(
                            child: Text(
                              '${subtask.subtaskNumber}. ${subtask.text}',
                              style: TextStyle(
                                color: subtask.completed
                                    ? theme.appColors.base5
                                    : theme.appColors.fg,
                                decoration: subtask.completed
                                    ? TextDecoration.lineThrough
                                    : TextDecoration.none,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                }),
              ],
            ),
          ),
          const SizedBox(height: 12),
        ],

        // AI Doporuƒçen√≠
        if (todo.aiRecommendations != null &&
            todo.aiRecommendations!.isNotEmpty) ...[
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.appColors.base1,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: theme.appColors.yellow, width: 1),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'üí° DOPORUƒåEN√ç:',
                  style: TextStyle(
                    color: theme.appColors.yellow,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  todo.aiRecommendations!,
                  style: TextStyle(
                    color: theme.appColors.fg,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 12),
        ],

        // AI Anal√Ωza term√≠nu
        if (todo.aiDeadlineAnalysis != null &&
            todo.aiDeadlineAnalysis!.isNotEmpty) ...[
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.appColors.base1,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: theme.appColors.magenta, width: 1),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '‚è∞ TERM√çN:',
                  style: TextStyle(
                    color: theme.appColors.magenta,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  todo.aiDeadlineAnalysis!,
                  style: TextStyle(
                    color: theme.appColors.fg,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          ),
        ],
      ],
    );
  }




  /// Otev≈ô√≠t AI Chat
  Future<void> _openAiChat(BuildContext context) async {
    // Zav≈ô√≠t kl√°vesnici
    FocusScope.of(context).unfocus();

    // Naƒç√≠st subtasks
    final subtasks = await _loadSubtasks(todo.id!);

    // Naƒç√≠st pomodoro sessions
    final sessions = await _loadPomodoroSessions(todo.id!);

    // Otev≈ô√≠t AI Chat page s task kontextem
    if (context.mounted) {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => AiChatPage.withTask(
            todo: todo,
            subtasks: subtasks,
            pomodoroSessions: sessions,
          ),
        ),
      );
    }
  }

  /// Naƒç√≠st subtasks z datab√°ze
  Future<List<SubtaskModel>> _loadSubtasks(int todoId) async {
    final db = DatabaseHelper();
    final maps = await db.getSubtasksByTodoId(todoId);
    return maps.map((m) => SubtaskModel.fromMap(m)).toList();
  }

  /// Naƒç√≠st pomodoro sessions z datab√°ze
  Future<List<PomodoroSession>> _loadPomodoroSessions(int todoId) async {
    final db = DatabaseHelper();
    final maps = await db.getPomodoroSessionsByTodoId(todoId);
    return maps.map((m) => PomodoroSession.fromMap(m)).toList();
  }

  /// Trigger AI Prank/Good Deed pokud je u≈æivatel v kategorii "child"
  ///
  /// St≈ô√≠d√°n√≠: lich√Ω count = prank, sud√Ω count = good deed
  ///
  /// ‚úÖ Kontroluje p≈ôipojen√≠ k internetu p≈ôed vol√°n√≠m AI
  void _triggerPrankIfChild(BuildContext context) {
    AppLogger.debug('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    AppLogger.debug('üöÄ _triggerPrankIfChild START (todo: ${todo.task})');
    AppLogger.debug('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    final theme = Theme.of(context);

    // üåê KROK 1: Kontrola p≈ôipojen√≠ k internetu (DOƒåASNƒö VYPNUTO - false positives na Android)
    // TODO: Opravit ConnectivityCubit pro Android emul√°tor
    final connectivityCubit = context.read<ConnectivityCubit>();
    AppLogger.debug('üì∂ Connectivity check: isConnected=${connectivityCubit.isConnected}, type=${connectivityCubit.connectionType}');

    // POZN: ConnectivityCubit m√° probl√©my na Android emul√°toru (false positives)
    // ‚Üí Spol√©h√°me se na to, ≈æe API call s√°m sel≈æe pokud nen√≠ internet
    // ‚Üí Lep≈°√≠ UX: user uvid√≠ konkr√©tn√≠ API error m√≠sto generick√© "no internet" zpr√°vy

    /* VYPNUTO - false positives na Android
    if (!connectivityCubit.isConnected) {
      AppLogger.debug('‚ùå ≈Ω√°dn√© p≈ôipojen√≠ k internetu ‚Üí prank/good deed p≈ôeskoƒçen');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('üì° Pro tipy od AI pot≈ôebuje≈° p≈ôipojen√≠ k internetu'),
          backgroundColor: theme.appColors.yellow,
          duration: const Duration(seconds: 3),
        ),
      );
      AppLogger.debug('üèÅ _triggerPrankIfChild KONEC (d≈Øvod: no internet)');
      return;
    }
    */

    AppLogger.debug('‚úÖ P≈ôeskakuji connectivity check (Android emul√°tor workaround) ‚Üí pokraƒçuji');

    // üë§ KROK 2: Z√≠skat profil u≈æivatele
    final profileBloc = context.read<ProfileBloc>();
    final profileState = profileBloc.state;
    AppLogger.debug('üë§ ProfileBloc state: ${profileState.runtimeType}');

    if (profileState is! ProfileLoaded) {
      AppLogger.debug('‚ö†Ô∏è ProfileBloc nen√≠ ProfileLoaded ‚Üí prank/good deed p≈ôeskoƒçen');
      AppLogger.debug('üèÅ _triggerPrankIfChild KONEC (d≈Øvod: profile not loaded)');
      return;
    }

    final userProfile = profileState.userProfile;
    AppLogger.debug('üìä User profile: ${userProfile != null ? "EXISTS" : "NULL"}');

    if (userProfile == null) {
      AppLogger.debug('‚ö†Ô∏è User profile je null ‚Üí prank/good deed p≈ôeskoƒçen');
      AppLogger.debug('üèÅ _triggerPrankIfChild KONEC (d≈Øvod: profile is null)');
      return;
    }

    final ageCategory = userProfile.ageCategory;
    final age = userProfile.age;
    final count = userProfile.completedTasksCount;

    AppLogger.debug('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    AppLogger.debug('üìã USER PROFILE INFO:');
    AppLogger.debug('  Name: ${userProfile.firstName} ${userProfile.lastName}');
    AppLogger.debug('  Age: $age');
    AppLogger.debug('  Age Category: ${ageCategory.name} (${ageCategory.czechName}) ${ageCategory.emoji}');
    AppLogger.debug('  Completed Tasks Count: $count');
    AppLogger.debug('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // üéØ KROK 3: Kontrola: pouze pro dƒõti (6-11 let podle fromAge v AgeCategory)
    if (ageCategory != AgeCategory.child) {
      AppLogger.debug('‚ÑπÔ∏è U≈æivatel NEN√ç d√≠tƒõ (category: ${ageCategory.name}) ‚Üí prank/good deed p≈ôeskoƒçen');
      AppLogger.debug('üèÅ _triggerPrankIfChild KONEC (d≈Øvod: not a child)');
      return;
    }

    AppLogger.debug('‚úÖ U≈æivatel JE d√≠tƒõ ‚Üí pokraƒçuji s generov√°n√≠m prank/good deed');

    final isOdd = count % 2 == 1; // Lich√Ω = prank, sud√Ω = good deed
    final type = isOdd ? 'PRANK' : 'GOOD DEED';

    AppLogger.debug('üé≤ Count=$count ‚Üí isOdd=$isOdd ‚Üí TYPE=$type');

    try {
      if (isOdd) {
        AppLogger.debug('üé≠ Vol√°m PrankCubit.generatePrank()...');
        context.read<PrankCubit>().generatePrank(todo);
        AppLogger.debug('‚úÖ PrankCubit.generatePrank() zavol√°no');
      } else {
        AppLogger.debug('üíö Vol√°m PrankCubit.generateGoodDeed()...');
        context.read<PrankCubit>().generateGoodDeed(todo);
        AppLogger.debug('‚úÖ PrankCubit.generateGoodDeed() zavol√°no');
      }
    } catch (e, stackTrace) {
      AppLogger.error('‚ùå EXCEPTION p≈ôi vol√°n√≠ PrankCubit', error: e, stackTrace: stackTrace);
    }

    AppLogger.debug('üèÅ _triggerPrankIfChild KONEC (SUCCESS)');
    AppLogger.debug('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  }
}
